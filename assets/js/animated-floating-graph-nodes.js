/*
 * Animated floating graph nodes (compiled from TypeScript)
 *
 * Copyright (c) 2022 Project Nayuki
 * All rights reserved. Contact Nayuki for licensing.
 * https://www.nayuki.io/page/animated-floating-graph-nodes
 */
"use strict";var app;!function(){function t(){let t=new i;e(t);let s=document.querySelector("svg");t.setOutput(s).initSvgGraph(),setInterval(()=>{t.stepFrame(),t.redrawOutput()},20)}function e(t){t.idealNumNodes=100,t.extraEdgeProportion=.3,t.radiiWeightPower=1,t.driftSpeed=1e-4,t.repulsionForce=1e-6}class s{constructor(){this.idealNumNodes=NaN,this.extraEdgeProportion=NaN,this.radiiWeightPower=NaN,this.driftSpeed=NaN,this.repulsionForce=NaN,this.borderFade=-.02,this.fadeInPerFrame=.06,this.fadeOutPerFrame=-.03,this.relWidth=NaN,this.relHeight=NaN,this.frameNumber=NaN,this.nodes=[],this.edges=[]}setDimensions(t,e){if(t<0||t>1||e<0||e>1||1!=t&&1!=e)throw new Error("Assertion error");return this.relWidth=t,this.relHeight=e,this}initGraph(){this.nodes=[],this.edges=[],this.frameNumber=0}stepFrame(){this.updateNodes(),this.updateEdges(),this.frameNumber++}updateNodes(){let t=[],e=Math.min(Math.floor(this.frameNumber/3),this.idealNumNodes);for(let s of this.nodes){s.posX+=s.velX*this.driftSpeed,s.posY+=s.velY*this.driftSpeed,s.velX=.99*s.velX+.3*(Math.random()-.5),s.velY=.99*s.velY+.3*(Math.random()-.5);const i=Math.min(s.posX,this.relWidth-s.posX,s.posY,this.relHeight-s.posY);s.fade(t.length<e&&i>this.borderFade?this.fadeInPerFrame:this.fadeOutPerFrame),s.opacity>0&&t.push(s)}for(;t.length<e;)t.push(new r(Math.random()*this.relWidth,Math.random()*this.relHeight,.015*(Math.pow(Math.random(),5)+.35),0,0));this.nodes=t,this.doForceField()}doForceField(){for(let t=0;t<this.nodes.length;t++){let e=this.nodes[t];e.dPosX=0,e.dPosY=0;for(let s=0;s<t;s++){let t=this.nodes[s],i=e.posX-t.posX,o=e.posY-t.posY;const r=i*i+o*o,h=this.repulsionForce/(Math.sqrt(r)*(r+1e-5));i*=h,o*=h,e.dPosX+=i,e.dPosY+=o,t.dPosX-=i,t.dPosY-=o}}for(let t of this.nodes)t.posX+=t.dPosX,t.posY+=t.dPosY}updateEdges(){let t=this.calcAllEdgeWeights();const e=Math.round((this.nodes.length-1)*(1+this.extraEdgeProportion));let i=this.calcSpanningTree(t);for(const[o,r,n]of t){if(i.length>=e)break;let t=new h(this.nodes[r],this.nodes[n]);s.containsEdge(i,t)||i.push(t)}let o=[];for(let t of this.edges)t.fade(s.containsEdge(i,t)?this.fadeInPerFrame:this.fadeOutPerFrame),Math.min(t.opacity,t.nodeA.opacity,t.nodeB.opacity)>0&&o.push(t);for(const t of i){if(o.length>=e)break;s.containsEdge(o,t)||o.push(t)}this.edges=o}calcAllEdgeWeights(){let t=[];for(let e=0;e<this.nodes.length;e++){const s=this.nodes[e];for(let i=0;i<e;i++){const o=this.nodes[i];let r=Math.hypot(s.posX-o.posX,s.posY-o.posY);r/=Math.pow(s.radius*o.radius,this.radiiWeightPower),t.push([r,e,i])}}return t.sort((t,e)=>t[0]-e[0])}calcSpanningTree(t){let e=[],s=new n(this.nodes.length);for(const[i,o,r]of t)if(s.mergeSets(o,r)&&(e.push(new h(this.nodes[o],this.nodes[r])),e.length>=this.nodes.length-1))break;return e}static containsEdge(t,e){for(const s of t)if(s.nodeA==e.nodeA&&s.nodeB==e.nodeB||s.nodeA==e.nodeB&&s.nodeB==e.nodeA)return!0;return!1}}class i extends s{constructor(){super(...arguments),this.svgElem=null}setOutput(t){let e=t.getBoundingClientRect();this.setDimensions(e.width/Math.max(e.width,e.height),e.height/Math.max(e.width,e.height)),this.svgElem=t,t.setAttribute("viewBox",`0 0 ${this.relWidth} ${this.relHeight}`);t.querySelector("rect");return t.setAttribute("width",this.relWidth.toString()),t.setAttribute("height",this.relHeight.toString()),t.querySelectorAll("stop")[0].setAttribute("stop-color","#4d4e54"),t.querySelectorAll("stop")[1].setAttribute("stop-color","#FFFFFF"),this}initSvgGraph(){this.initGraph(),this.redrawOutput()}redrawOutput(){function t(t,s){let i=document.createElementNS(e.namespaceURI,t);for(const t in s)i.setAttribute(t,s[t].toString());return i}if(null===this.svgElem)throw new Error("Invalid state");let e=this.svgElem,s=e.querySelector("g");for(;null!==s.firstChild;)s.removeChild(s.firstChild);for(const e of this.nodes)s.append(t("circle",{cx:e.posX,cy:e.posY,r:e.radius,fill:"rgba(77,78,84,"+e.opacity.toFixed(3)+")"}));for(const e of this.edges){const i=e.nodeA,o=e.nodeB;let r=i.posX-o.posX,h=i.posY-o.posY;const n=Math.hypot(r,h);if(n>i.radius+o.radius){r/=n,h/=n;const a=Math.min(Math.min(i.opacity,o.opacity),e.opacity);s.append(t("line",{x1:i.posX-r*i.radius,y1:i.posY-h*i.radius,x2:o.posX+r*o.radius,y2:o.posY+h*o.radius,stroke:"rgba(77,78,84,"+a.toFixed(3)+")"}))}}}}class o{constructor(){this.opacity=0}fade(t){this.opacity=Math.max(Math.min(this.opacity+t,1),0)}}class r extends o{constructor(t,e,s,i,o){super(),this.posX=t,this.posY=e,this.radius=s,this.velX=i,this.velY=o,this.dPosX=0,this.dPosY=0}}class h extends o{constructor(t,e){super(),this.nodeA=t,this.nodeB=e}}class n{constructor(t){this.parents=[],this.ranks=[];for(let e=0;e<t;e++)this.parents.push(e),this.ranks.push(0)}mergeSets(t,e){const s=this.getRepr(t),i=this.getRepr(e);if(s==i)return!1;const o=this.ranks[s]-this.ranks[i];return o>=0?(0==o&&this.ranks[s]++,this.parents[i]=s):this.parents[s]=i,!0}getRepr(t){return this.parents[t]!=t&&(this.parents[t]=this.getRepr(this.parents[t])),this.parents[t]}}t()}(app||(app={}));